"""
Shared State Definition for JurisLink Multi-Agent System.
Version 4.0: Type-Safe Contracts with Validation

This module defines the central CaseState TypedDict that flows through all agents.
All agents MUST return dictionaries that match these exact keys.
"""
from typing import TypedDict, List, Optional, Dict, Any, Annotated, Literal
from langchain_core.messages import BaseMessage, HumanMessage, AIMessage
from langgraph.graph.message import add_messages


# =============================================================================
# TYPE DEFINITIONS
# =============================================================================

class CaseFacts(TypedDict, total=False):
    """Structured case facts extracted by Intake Agent."""
    client_name: str
    opposing_party: str
    employer: str
    job_title: str
    incident_summary: str
    date_of_incident: str
    location: str
    jurisdiction: str
    case_type: str
    witnesses: str
    damages: str
    status: Literal["IN_PROGRESS", "COMPLETE"]


class GeneratedDocs(TypedDict, total=False):
    """Documents generated by Writer Agent."""
    demand_letter: str  # Base64-encoded PDF
    reasoning_memo: str  # Base64-encoded PDF


class CaseState(TypedDict, total=False):
    """
    The central state object that flows through the LangGraph.
    
    CRITICAL: All agent return dictionaries MUST use these exact keys.
    Key mapping reference:
        - intake_node    -> case_facts, next_step
        - researcher_node -> legal_research, next_step
        - strategist_node -> strategy_brief, next_step
        - critic_node    -> critic_feedback, next_step
        - writer_node    -> generated_docs, next_step
    """
    # ---------------------------------------------------------
    # CORE CONVERSATION STATE
    # ---------------------------------------------------------
    messages: Annotated[List[BaseMessage], add_messages]  # Auto-accumulates
    
    # ---------------------------------------------------------
    # AGENT OUTPUTS (Strict Keys)
    # ---------------------------------------------------------
    case_facts: Dict[str, Any]           # Intake Agent output
    legal_research: Optional[str]        # Researcher Agent output (markdown)
    strategy_brief: Optional[str]        # Strategist Agent output (markdown)
    critic_feedback: Optional[str]       # Critic Agent output (markdown)
    generated_docs: Optional[GeneratedDocs]  # Writer Agent output
    
    # ---------------------------------------------------------
    # ROUTING CONTROL
    # ---------------------------------------------------------
    next_step: Optional[str]  # Valid values: "researcher", "strategist", "critic", "writer", "end", None
    
    # ---------------------------------------------------------
    # METADATA
    # ---------------------------------------------------------
    language: Optional[str]           # "en", "es", "fr", "zh", "hi"
    reasoning_trace: Optional[str]    # Trace of thinking steps for UI
    iteration_count: int              # How many times the chain has been refined
    session_id: Optional[str]         # Unique identifier for conversation
    
    # ---------------------------------------------------------
    # ERROR HANDLING
    # ---------------------------------------------------------
    error: Optional[str]              # Error message if any agent fails
    error_source: Optional[str]       # Which agent caused the error


# =============================================================================
# FACTORY FUNCTION
# =============================================================================

def create_initial_state(
    messages: List[BaseMessage] = None,
    language: str = "en",
    session_id: str = None
) -> CaseState:
    """
    Create a properly initialized CaseState with all defaults set.
    Use this instead of manually constructing dictionaries.
    """
    return {
        "messages": messages or [],
        "case_facts": {},
        "legal_research": None,
        "strategy_brief": None,
        "critic_feedback": None,
        "generated_docs": None,
        "next_step": None,
        "language": language,
        "reasoning_trace": "[Turn 1] Starting new conversation.",
        "iteration_count": 1,
        "session_id": session_id,
        "error": None,
        "error_source": None,
    }


# =============================================================================
# VALIDATION HELPERS
# =============================================================================

VALID_NEXT_STEPS = {"researcher", "strategist", "critic", "writer", "end", None}
VALID_LANGUAGES = {"en", "es", "fr", "zh", "hi"}

def validate_agent_output(agent_name: str, output: dict) -> dict:
    """
    Validate that an agent's output uses correct keys.
    Logs warnings if unexpected keys are found.
    Returns the output unchanged (for chaining).
    """
    expected_keys = {
        "intake_agent": {"messages", "case_facts", "next_step"},
        "researcher_agent": {"legal_research", "next_step", "error", "error_source"},
        "strategist_agent": {"strategy_brief", "next_step"},
        "critic_agent": {"critic_feedback", "next_step"},
        "assistant_agent": {"generated_docs", "next_step"},
    }
    
    agent_expected = expected_keys.get(agent_name, set())
    output_keys = set(output.keys())
    unexpected = output_keys - agent_expected - {"error", "error_source"}
    
    if unexpected:
        print(f"⚠️ WARNING [{agent_name}]: Unexpected keys in output: {unexpected}")
    
    return output


# =============================================================================
# SERIALIZATION (for frontend/API)
# =============================================================================

def serialize_state(state: CaseState) -> dict:
    """Convert CaseState to JSON-serializable dictionary."""
    serialized = dict(state)
    
    # Convert messages to serializable format
    if "messages" in serialized and serialized["messages"]:
        serialized["messages"] = [
            {
                "role": "user" if getattr(m, 'type', None) == 'human' else "assistant",
                "content": m.content
            }
            for m in serialized["messages"]
        ]
    
    # Remove bytes (can't serialize)
    if "document_bytes" in serialized:
        del serialized["document_bytes"]
    
    return serialized


def deserialize_state(data: dict) -> CaseState:
    """Convert JSON dict back to CaseState-compatible format."""
    state = dict(data)
    
    # Convert message dicts to LangChain messages
    if "messages" in state and state["messages"]:
        messages = []
        for msg in state["messages"]:
            if isinstance(msg, dict):
                if msg.get("role") == "user":
                    messages.append(HumanMessage(content=msg.get("content", "")))
                else:
                    messages.append(AIMessage(content=msg.get("content", "")))
            else:
                messages.append(msg)
        state["messages"] = messages
    else:
        state["messages"] = []
    
    # Ensure all required fields exist with defaults
    defaults = {
        "case_facts": {},
        "legal_research": None,
        "strategy_brief": None,
        "critic_feedback": None,
        "generated_docs": None,
        "next_step": None,
        "language": "en",
        "reasoning_trace": "",
        "iteration_count": 0,
        "session_id": None,
        "error": None,
        "error_source": None,
    }
    
    for key, default in defaults.items():
        if key not in state:
            state[key] = default
    
    return state
